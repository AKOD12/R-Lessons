---
title: "Introduction to Regression"
author: "Ankith Kodali"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

To start this lesson lets load in ba_2014_2015 which has batting averages for the 2014-2015 MLB season. We are going to be focusing on the batting averages of players between the 2014 and 2015 seasons.

```{r echo=TRUE}
library(tidyverse)
ba_2014_2015 <- read_csv("C:/Users/ankit/OneDrive/Desktop/Robotics Scouting/Data Sets/ba_2014_2015.csv")
ba_2014_2015
```



###Predicting Averages###
Let's say there is a player who played in 2014 and 2015 but is not in our dataset. We known absolutely nothing about the player so how could we predict their 2015 batting average using the data that we have? The simplest thing (which actually works pretyy well) to do in our case is to use the overall mean of the 2015 batting averages in our dataset to predict the batting average of unknown player.

Imagine if we were also able to get this mystery player's 2014 batting average? Can we improve on this simple prediction? In this lesson, we will go through various ways of predicting 2015 batting average using 2014 batting average. In order to decide the best method for this instance we will decide how well each method predicts the actual 2015 batting averages in our tbl. We will add columns to our current tibble to compare predicitions against reality. Let's start off by adding a column containing the overall mean of the 2015 batting averages. The 2015 season mean is 0.273, while the mean 2014 mean is 0.272. We are going to be using the term yhat here which is often associated with regreesion.

```{r echo=TRUE}
ba_2014_2015 <- mutate(ba_2014_2015,yhat_1 = mean(ba_2015))
```

If the 2014 batting average was not related to the 2015 averages at all, then the 2015 overall mean will be the best prediction model with the data we have. We can plot the 2015 batting averages against the 2014 batting averages to see visually whether there is any relationship between the two seasons data. We can add dashed horizontal and vertical lines for overall means of the 2014 and 2015 seasons respectively.


```{r echo=TRUE}
ggplot(ba_2014_2015) + geom_point(aes(x = ba_2014, y = ba_2015), col = "black", shape=16,
    size = 0.9) + geom_hline(yintercept = 0.273, col = "blue", lty = 3) + 
     geom_vline(xintercept = 0.272, col = "blue", lty = 3)
```

It looks like there is a relationship so it's at least reasonable to use the 2014 batting averages to make predictions for 2015 we can be more accurate though.

Looking at the plot we see that most players with below average batting averages in 2014 tended to also have below average batting averages in 2015. Similarly, most players with above average batting averages in 2014 tended to have above average batting averages in 2015.

Here is one way to imporve this-

We can divide the players into two groups, one for those with above average ba in 2014 and one for those with below average ba in 2014. We can then average the 2015 ba within our two new groups and use these averages as the prediction for each member of the group. In order to do this, we will need to create a column indicating which group each player belongs. Then we can pass this column to `group_by()` and compute the average ba_2015 within each group. To create the column we will use the powerful `cut()` function, which divides the range of a numerical vector into intervals and recodes the numerical values according to which interval they fall.

The following does what was aid above with two more steps- once we have made our predictions, we ungroup the tbl and we can drop the column indicating the interval in which our observation falls.

```{r echo=TRUE}
ba_2014_2015 <- ba_2014_2015 %>% mutate(bins = cut(ba_2014, breaks = c(0.15, 0.272, 0.4))) %>% 
  group_by(bins) %>% mutate(yhat_2 = mean(ba_2015)) %>% 
  ungroup() %>% select(-bins)
```

When we run this code and print out our tbl, we see that there is a new column called "yhat_2" that contains our new predictions. Before continuing, understand the syntax used in cut(). The first argument is the variable we want to approximate. The next argument,  `breaks =` is a vector that tells R where the endpoints of these intervals (bins) are. These are often called "cut points" In this particular case, we wanted to divide the players into those with below average ba in 2014 and above average ba in 2015. The first element of the cut point vector, 0.15 is much less than the smallest ba_2014 value, whereas the second elements, 0.272, is the overall mean of the ba_2014 values. The last element, 0.40 is much greater than the largest ba_2014 value.

Now if we look at this visually-

```{r echo=TRUE}
ggplot(ba_2014_2015) + geom_point(aes(x = ba_2014, y = ba_2015), col = "black", shape = 16, size = 0.9) + 
     geom_point(aes(x = ba_2014, y = yhat_1), col = "red", shape = 3, size = 0.75) + 
     geom_point(aes(x = ba_2014, y = yhat_2), col = "green", shape = 15, size = 0.75)
```

Visually it appears that the green squares (corresponding to yhat_2) are a bit closer to the actual values than the red crosses (corresponding to yhat_1). This would suggest that dividing the players into the two bins according to their 2014 batting average and using the average average 2015 value within each bin as our forecast was better than using the overall average 2015 value for all players.

We can continue with this process and divide the players into even more bins. When we do that, instead of hand-coding the vector of cut points, we can use the function seq() which generates a vector of equally spaced numbers. To demonstrate, suppose we wanted to divide the interval [0,1] into 10 equally sized intervals: (0,0.1], (0.1, 0.2], ., (0.9, 1]. To get the vector of cutpoints, we need to tell seq() either how many points we wanted or the spacing between the points:

```{r echo=TRUE}
seq(from = 0, to = 1, length = 11)
```

Now let's divde the 2014 batting averages into intervals of length 0.05 and predict 2015 batting averages using the average ba_2015 values within the resulting bins. 

```{r echo=TRUE}
ba_2014_2015 <- ba_2014_2015 %>% mutate(bins = cut(ba_2014, breaks = seq(from = 0.15, 
     to = 0.4, by = 0.05))) %>% group_by(bins) %>% mutate(yhat_3 = mean(ba_2015)) %>% 
     ungroup() %>% select(-bins)
```

Then we visualize-

```{r echo=TRUE}
ggplot(ba_2014_2015) + geom_point(aes(x = ba_2014, y = ba_2015), shape = 16, size = 0.9) +
  geom_point(aes(x = ba_2014, y = yhat_1), col = "red", shape = 3, size = 0.75) +
  geom_point(aes(x = ba_2014, y = yhat_2), col = "green", shape = 15, size = 0.75) + 
  geom_point(aes(x = ba_2014, y = yhat_3), col = "blue", shape = 17, size = 0.75)
```

It appears that we are able to predict the 2015 batting average of the player with the lowest batting average in 2014 pretty well.

**Exercise** Add a new column "yhat_3" to our tbl that contains the predictions formed when we divide the 2014 batting averages into bins of length 0.005. Plot these new predictions in purple using shape = 8. What do you notice about these predictions?

```{r echo=FALSE}
ba_2014_2015 <- ba_2014_2015 %>% mutate(bins = cut(ba_2014, breaks = seq(from = 0.15, 
     to = 0.4, by = 0.005))) %>% group_by(bins) %>% mutate(yhat_4 = mean(ba_2015)) %>% 
     ungroup() %>% select(-bins)
```


```{r echo=FALSE, eval=TRUE}
ggplot(ba_2014_2015) + geom_point(aes(x = ba_2014, y = ba_2015), shape = 16, size = 0.9) +
  geom_point(aes(x = ba_2014, y = yhat_1), col = "red", shape = 3, size = 0.75) +
  geom_point(aes(x = ba_2014, y = yhat_2), col = "green", shape = 15, size = 0.75) + 
  geom_point(aes(x = ba_2014, y = yhat_3), col = "blue", shape = 17, size = 0.75) +
  geom_point(aes(x = ba_2014, y = yhat_4), col = "purple", shape = 8, size = 0.75)
```

###Assessing Predictive Power###

We now have a couple of different ways of predicting 2015 batting average. Qualitatively, the predictions in purple (smallest bins) appear to fit the observed data better than the blue, green, and red predictions. To assess the predictions quantitatively, we use the root mean square error or RMSE. This is the square root of the mean square error (MSE), which is computed by averaging the squared difference between the actual values and the predicted values.

```{r echo=TRUE}
summarize(ba_2014_2015, rmse_1 = sqrt(mean((ba_2015 - yhat_1)^2)), 
          rmse_2 = sqrt(mean((ba_2015 - yhat_2)^2)), 
          rmse_3 = sqrt(mean((ba_2015 - yhat_3)^2)), 
          rmse_4 = sqrt(mean((ba_2015 - yhat_4)^2)))
```

The RMSEs confirm what we could see visually- the purple predictions fit the data much better than the blue, green, and red predictions. Moreover we see that the predictions formed by binning into smaller intervals yielded smaller RMSEs than the predictions formed by binning into larger intervals.

**Exercise** Add another column of predictions, "yhat_5", which are computed by dividing ba_2014 into intervals of length 0.001. Re-compute the RMSEs and plot all of the predictions again. Use col = 'orange, shape = 10 for these new predictions.

```{r echo=FALSE}
ba_2014_2015 <- ba_2014_2015 %>% mutate(bins = cut(ba_2014, breaks = seq(from = 0.15, 
     to = 0.4, by = 0.001))) %>% group_by(bins) %>% mutate(yhat_5 = mean(ba_2015)) %>% 
     ungroup() %>% select(-bins)
```

```{r echo=FALSE, eval=TRUE}
ggplot(ba_2014_2015) + geom_point(aes(x = ba_2014, y = ba_2015), shape = 16, size = 0.9) +
  geom_point(aes(x = ba_2014, y = yhat_1), col = "red", shape = 3, size = 0.75) +
  geom_point(aes(x = ba_2014, y = yhat_2), col = "green", shape = 15, size = 0.75) + 
  geom_point(aes(x = ba_2014, y = yhat_3), col = "blue", shape = 17, size = 0.75) +
  geom_point(aes(x = ba_2014, y = yhat_4), col = "purple", shape = 8, size = 0.75) +
  geom_point(aes(x = ba_2014, y = yhat_5), col = "orange", shape = 10, size = 0.75)
```

```{r echo=FALSE, eval=TRUE}
summarize(ba_2014_2015, rmse_1 = sqrt(mean((ba_2015 - yhat_1)^2)), 
          rmse_2 = sqrt(mean((ba_2015 - yhat_2)^2)), 
          rmse_3 = sqrt(mean((ba_2015 - yhat_3)^2)), 
          rmse_4 = sqrt(mean((ba_2015 - yhat_4)^2)),
          rmse_5 = sqrt(mean((ba_2015 - yhat_5)^2)))
```

